<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2023-01-01" />
  <meta name="keywords" content="лекции, мфти, мещерин, мещерин
илья, тех, техать, 1 курс" />
  <title>С++</title>
  <link rel="stylesheet" href="styles.css">
<link href="prism-monokai.css" rel="stylesheet">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&display=swap" rel="stylesheet">
<!--<link rel="stylesheet" type="text/css" href="https://jsxgraph.org/distrib/jsxgraph.css" />
 <script type="text/javascript" src="https://jsxgraph.org/distrib/jsxgraphcore.js"></script>-->
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">С++</h1>
<p class="date">2023</p>
</header>
<details>
<summary>Содержание</summary>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#выражения-и-операторы"
id="toc-выражения-и-операторы">Выражения и операторы</a>
<ul>
<li><a href="#операторы" id="toc-операторы">Операторы</a>
<ul>
<li><a href="#арифметические-операторы-arithmetic-operators"
id="toc-арифметические-операторы-arithmetic-operators">Арифметические
операторы (Arithmetic operators)</a></li>
<li><a href="#битовые-операторы-bitwise-operators"
id="toc-битовые-операторы-bitwise-operators">Битовые операторы (Bitwise
operators)</a></li>
<li><a href="#операторы-сравнения-comparison-operators"
id="toc-операторы-сравнения-comparison-operators">Операторы сравнения
(Comparison operators)</a></li>
<li><a href="#логические-операторы-logical-operators"
id="toc-логические-операторы-logical-operators">Логические операторы
(Logical operators)</a></li>
<li><a href="#инкремент-и-декремент-increment-and-decrement"
id="toc-инкремент-и-декремент-increment-and-decrement">Инкремент и
декремент (Increment and Decrement)</a></li>
<li><a
href="#присваивание-и-составное-присваивание-assignment-and-compound-assignment"
id="toc-присваивание-и-составное-присваивание-assignment-and-compound-assignment">Присваивание
и составное присваивание (Assignment and Compound assignment)</a></li>
<li><a href="#оператор-sizeof" id="toc-оператор-sizeof">Оператор <code class="language-cpp">sizeof</code></a></li>
<li><a href="#тернарный-оператор-ternary-operator"
id="toc-тернарный-оператор-ternary-operator">Тернарный оператор (Ternary
operator)</a></li>
<li><a href="#оператор-запятая-operator-comma"
id="toc-оператор-запятая-operator-comma">Оператор запятая (Operator
comma)</a></li>
</ul></li>
<li><a
href="#приоритет-операторов-operator-precedence-и-порядок-вычисления-order-of-evaluation"
id="toc-приоритет-операторов-operator-precedence-и-порядок-вычисления-order-of-evaluation">Приоритет
операторов (operator precedence) и порядок вычисления (order of
evaluation)</a>
<ul>
<li><a href="#упражнение" id="toc-упражнение">Упражнение</a></li>
</ul></li>
<li><a href="#понятия-rvalue-и-lvalue"
id="toc-понятия-rvalue-и-lvalue">Понятия rvalue и lvalue</a></li>
</ul></li>
</ul>
</nav>
</details>
<h1 id="выражения-и-операторы">Выражения и операторы</h1>
<hr />
<p>Любое выражение что-то возвращает.</p>
<h2 id="операторы">Операторы</h2>
<h3 id="арифметические-операторы-arithmetic-operators">Арифметические
операторы (Arithmetic operators)</h3>
<p>Это бинарные операторы (<code class="language-cpp">-</code> и <code class="language-cpp">+</code> могут быть унарными).</p>
<p><code class="language-cpp">+</code> - сложение</p>
<p><code class="language-cpp">-</code> - вычитание</p>
<p><code class="language-cpp">/</code> - деление (целочисленное, если оба
операнда целочисленные, если хотя бы один вещественный, то обычное
деление)</p>
<p><code class="language-cpp">*</code> - умножение</p>
<p><code class="language-cpp">%</code> - остаток от деления (слегка
нематематический)</p>
<h3 id="битовые-операторы-bitwise-operators">Битовые операторы (Bitwise
operators)</h3>
<p>Правый и левый операнды должны быть выражениями, результатом которых
являются <code class="language-cpp">unsigned</code> целочисленные типы.</p>
<p><code class="language-cpp">|</code> - побитовое или (or)</p>
<p><code class="language-cpp">&amp;</code> - побитовое и (and)</p>
<p><code class="language-cpp">^</code> - побитовое исключающее или (xor)</p>
<p><code class="language-cpp">~</code> - инверсия битов: 0 заменяется на 1, а 1
на ноль</p>
<p><code class="language-cpp">&lt;&lt;</code> - побитовый сдвиг влево. Для
потоков эти операторы определены иначе, то есть, когда написано <code class="language-cpp">std::cout &lt;&lt; "hmm\n";</code> никаких сдвигов не
происходит :)</p>
<p><code class="language-cpp">&gt;&gt;</code> - побитовый сдвиг вправо</p>
<h3 id="операторы-сравнения-comparison-operators">Операторы сравнения
(Comparison operators)</h3>
<p><code class="language-cpp">&gt;= &lt;= != == &gt; &lt;</code></p>
<h3 id="логические-операторы-logical-operators">Логические операторы
(Logical operators)</h3>
<p>Можно применять к булевым выражениям.</p>
<p><code class="language-cpp">||</code> - логическое или</p>
<p><code class="language-cpp">&amp;&amp;</code> - логическое и</p>
<p><code class="language-cpp">!</code> - отрицание</p>
<p>Вычисляется сначала выражение слева от оператора, и если по нему
можно дать ответ, то выражение справа не вычисляется.</p>
<p>Например:</p>
<pre class="language-cpp"><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
    int a = -1;
    int b = 1;

    if (a++ &amp;&amp; b++) { // b не увеличится на 1, так как это
        // выражение не будет посчитано (-1 + 1 == 0),
        //а ноль кастится в false
        std::cout &lt;&lt; &quot;hmm\n&quot;;
    }
}</code></pre>
<h3 id="инкремент-и-декремент-increment-and-decrement">Инкремент и
декремент (Increment and Decrement)</h3>
<p>Инкремент - это <code class="language-cpp">++</code>. Бывает префиксный (когда
<code class="language-cpp">++</code> перед выражением) и постфиксный (когда <code class="language-cpp">++</code> после выражения).</p>
<pre class="language-cpp"><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
    int x = 5;
    int y = ++x; // увеличивает на 1 и возвращает результат
    int z = x++; // увеличивает на 1 и возвращает то, что было

    // префиксный инкремент в среднем эффективнее,
    // потому что требует меньшего числа операций
    // для постфиксного инкремента нужна операция,
    // чтобы созранить то, что было

    std::cout &lt;&lt; x &lt;&lt; &quot;\n&quot;; // 7, так как дважды увеличили на 1
    std::cout &lt;&lt; y &lt;&lt; &quot;\n&quot;; // 6, так как 5 + 1 = 6
    std::cout &lt;&lt; z &lt;&lt; &quot;\n&quot;; // 6, так как прибавляли 1 к 6
}</code></pre>
<p>Декремент - это <code class="language-cpp">--</code>. Все как у
инкремента.</p>
<h3
id="присваивание-и-составное-присваивание-assignment-and-compound-assignment">Присваивание
и составное присваивание (Assignment and Compound assignment)</h3>
<p>Оператор присваивания - <code class="language-cpp">=</code>.</p>
<p>Операторы составного присваивания - <code class="language-cpp">+= -= *= /= %= ^= &amp;= |= &lt;&lt;= &gt;&gt;=</code>.</p>
<p><code class="language-cpp">a += b;</code> это тоже самое, что <code class="language-cpp">a = a + b;</code>. И так для любого оператора составного
присваивания.</p>
<p>Но операторы составного присваивания использовать предпочтительнее,
так как они эффективнее <a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> .</p>
<p><code class="language-cpp">a = b</code> - это выражение, а значит оно что-то
возвращает. Что? Результат, поэтому в c++ можно написать <code class="language-cpp">a = b = c</code>, причем <code class="language-cpp">=</code>
<strong>правоассоциативен</strong>, то есть <code class="language-cpp">a = b = c</code> парсится слева направо и эквивалентно <code class="language-cpp">a = (b = c)</code>. Тоже самое работает и для операторов
составного присваивания <code class="language-cpp">a *= b += c</code>.</p>
<h3 id="оператор-sizeof">Оператор <code class="language-cpp">sizeof</code></h3>
<p>Можно писать <code class="language-cpp">sizeof(expression)</code>.</p>
<p>Компилятор еще в момент компиляции знает размер всех типов. И все
<code class="language-cpp">sizeof</code> просто заменяются на числа. <code class="language-cpp">sizeof(expression)</code> возвращает количество байт,
которое занимает тип результата выражения в стеке программы.</p>
<p>Можно писать <code class="language-cpp">sizeof expression</code> (без скобок и
с пробелом).</p>
<h3 id="тернарный-оператор-ternary-operator">Тернарный оператор (Ternary
operator)</h3>
<pre class="language-cpp"><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
    // тернарный, потому что единственный оператор, у которого три операнда

    // тернарный оператор - это сокращенная запись ифа

    // bool-expression ? expression_if_true : expression_if_false

    // если bool-expression истинно, то выполнится expression_if_true
    // иначе expression_if_false

    bool i_hate_love_cpp = true;

    std::cout &lt;&lt; (i_hate_love_cpp ? &quot;😎\n&quot; : &quot;💀\n&quot;);

    // тернарный оператор возвращает результат того выражения,
    // которое было выполнено

    // (condition ? x : y) = 0; // так можно

    // с++ статически типизируемый, а значит тип возвращаемого
    // значения для любого выражения должен быть известен
    // на этапе компиляции

    // поэтому следующее неверно:

    // int x = 0;
    // std::string s = &quot;abc&quot;;
    // std::cout &lt;&lt; ((2 &lt; 3) ? x : s); // неверно, так как нельзя определить возвращать строку или число

    // но так можно:
    // int i = 0;
    // double d = 0.9;
    // std::cout &lt;&lt; ((2 &lt; 3) ? i : d); // верно, так как работает приведение типов

    // https://en.cppreference.com/w/cpp/language/operator_other
    // по ссылке выше подробно описано, как происходит
    // приведение типов в тернарном операторе
    // 🥴
}</code></pre>
<h3 id="оператор-запятая-operator-comma">Оператор запятая (Operator
comma)</h3>
<blockquote>
<p>Мой любимый оператор</p>
</blockquote>
<pre class="language-cpp"><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
    // Как работает оператор запятая?
    // Он вычисляет выражение слева, выражение справа
    // и возвращает результат правого выражения

    // гарантируется, что выражения вычисляются слева направо

    int x, y, z;

    z = (x = 0, y = 5, ++x, --y);

    std::cout &lt;&lt; z &lt;&lt; &quot;\n&quot;; // выведет 4

    (x = y, z = x) = y; // 😎

    std::cout &lt;&lt; z &lt;&lt; &quot;\n&quot;;
}</code></pre>
<h2
id="приоритет-операторов-operator-precedence-и-порядок-вычисления-order-of-evaluation">Приоритет
операторов (operator precedence) и порядок вычисления (order of
evaluation)</h2>
<hr />
<p><a
href="https://en.cppreference.com/w/cpp/language/operator_precedence">См.
ссылку</a></p>
<p>Вообще приоритета как такового нет. Есть грамматика языка <a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>, где определяется, что такое
выражения (expression) разных уровней <a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>.
Эти уровни и есть приотритет.</p>
<h3 id="упражнение">Упражнение</h3>
<pre class="language-cpp"><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
    int x = 0;

    ++x = x++;

    std::cout &lt;&lt; x &lt;&lt; &quot;\n&quot;; // до c++17 могло быть 0, 1 или 2.
    // как?
}</code></pre>
<h2 id="понятия-rvalue-и-lvalue">Понятия rvalue и lvalue</h2>
<hr />
<p><strong>lvalue</strong> (от left value) - неформально говоря, то,
чему можно присваивать.</p>
<p>Операторы: префиксный инкремент и декремент, оператор присваивания и
операторы составного присваивания - это lvalue.</p>
<p>Оператор запятая и тернарный оператор могут быть как lvalue, так и
rvalue в зависимости от возвращаемого значения.</p>
<p>На этапе компиляции компилятор должен понимать rvalue или lvalue
возвращает выражение.</p>
<pre class="language-cpp"><code class="language-cpp">#include &lt;iostream&gt;

int main()
{
    int a = 10, b = 15, x = 42;

    (a, b) = x; // так можно
    std::cout &lt;&lt; b &lt;&lt; &quot;\n&quot;;

    a + b = x; // так нельзя

    (2 &lt; 3 ? ++x : x++) = 4; // так тоже нельзя, потому что 
    // нельзя понять rvalue или rvalue вернет выражение

    ++x++; // CE, так как инкремент требует lvalue в качестве операнда

    ++++++x; // так можно
}</code></pre>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Не требуется отлельно вычислять <code class="language-cpp">a + b</code> и куда-то сохранять.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Грамматика описана в стандарте языка c++<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Определяется почти как формула в матлогике или теории
дискретных функций<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<script src="prism.js"></script>
<script src="copy_code.js"></script>
</body>
</html>
